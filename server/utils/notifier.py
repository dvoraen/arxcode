"""
Notifier.py

Contains classes for various forms of notifying players, PC GMs, staff, and
so on.  The purpose of these classes is to reduce code for sending messages
to specific subsets of the game.  (e.g. - send only to staff in a given room)


USAGE

The base Notifier class supports the following (boolean) to_flags arguments,
each of which default to False if not found in the to_flags argument:

* to_player - this notifier sends to non-gm players
* to_gm - this notifier sends to gm players
* to_staff - this notifier sends to staff players

Subclasses of Notifier differ in how they source characters, which is why
it is required to override _source_characters() when deriving from Notifier.

CODE USAGE
1. Initialize a notifier; see individual classes for to_flags documentation.
2. Notifier.generate() -- this must be called after setup but before any
   other methods or properties are called.  Call generate() only once.
3. Notifier.notify() -- this will send your message to the receivers
   generated by Notifier.generate().

INHERITANCE TREE

Notifier
- RoomNotifier
- ListNotifier
    - SelfListNotifier

EXAMPLE CODE

# This code will send "Hello, world!" to all player GMs
# and staff in the given room.
gm_notifier = RoomNotifier(
    caller,
    room=caller.location,
    to_gm=True,
    to_staff=True
)
gm_notifier.generate()
gm_notifier.notify("Hello, world!")
"""

from abc import ABC, abstractmethod
from typing import List, Dict, Optional

OptionsDict = Dict[str, bool]


class NotifyError(Exception):
    pass


class Notifier(ABC):
    """
    Abstract base class for sending notifications to the game.
    This class is meant to be derived from and its 'protected' code
    utilized in derived classes (to lower code duplication).
    """

    def __init__(
        self,
        caller,
        **to_flags,
    ):
        self.caller = caller
        self.to_flags = to_flags

        self.receiver_set = set()

    def __repr__(self):
        keys = [key for key in self.to_flags if self.to_flags[key]]
        return f"<Notifier: {', '.join(keys)}>"

    def generate(self):
        """Generates the receiver list for this notifier."""
        self._source_characters()
        self._filter_receivers()

    def notify(self, msg: str, options: Optional[OptionsDict] = None):
        """Notifies each receiver of msg with the given options, if any."""
        for rcvr in self.receiver_set:
            rcvr.msg(msg, options)

    def receivers(self):
        yield from self.receiver_set

    def players(self):
        yield from (pc for pc in self.receiver_set if not pc.check_staff_or_gm())

    def gms(self):
        yield from (pc for pc in self.receiver_set if pc.is_gm())

    def staff(self):
        yield from (pc for pc in self.receiver_set if pc.is_staff())

    def receiver_names(self) -> str:
        yield from (str(pc) for pc in self.receiver_set)

    def player_names(self) -> str:
        yield from (str(pc) for pc in self.receiver_set if not pc.check_staff_or_gm())

    def gm_names(self) -> str:
        yield from (str(pc) for pc in self.receiver_set if pc.is_gm())

    def staff_names(self) -> str:
        yield from (str(pc) for pc in self.receiver_set if pc.is_staff())

    @abstractmethod
    def _source_characters(self):
        pass

    def _filter_receivers(self):
        """Returns all receivers designated by the given receiver flags."""
        player_set = set()
        gm_set = set()
        staff_set = set()

        if self.to_flags.get("to_player", False):
            player_set = set(self.players())

        if self.to_flags.get("to_gm", False):
            gm_set = set(self.gms())

        if self.to_flags.get("to_staff", False):
            staff_set = set(self.staff())

        self.receiver_set = player_set | gm_set | staff_set


class DomainNotifier(Notifier):
    """
    Notifier for sending to the owner(s) of a domain.

    TO_FLAGS Supported:
    - to_staff - include staff in this notification
    - to_caller - include the caller in this notification (if applicable)
    """

    def __init__(self, caller, domain, **to_flags):
        super().__init__(caller, **to_flags)

        self.domain = domain

    def __repr__(self):
        keys = [key for key in self.to_flags if self.to_flags[key]]
        return f"<DomainNotifier: {self.domain}; {', '.join(keys)}>"

    def _source_characters(self):
        # Grab all the rulers of the domain or just the one?
        self._source_rulers()

        if self.to_flags.get("to_staff", False):
            self._source_staff()

        if self.to_flags.get("to_caller", False):
            self.receiver_set.add(self.caller)

    def _source_rulers(self):
        pass

    def _source_staff(self):
        staff_qs = AccountDB.objects.filter(db_is_connected=True, is_staff=True)
        for staff in staff_qs:
            self.receiver_set.add(staff)


class ListNotifier(Notifier):
    """
    Notifier for sending only to the passed in list of receivers,
    then filtered by the to_flags.

    TO_FLAGS Supported:
    - to_player - include non-gm players in this notification
    - to_gm - include player-gms in this notification
    - to_staff - include staff in this notification

    - to_global - sources players on the list from anywhere in the game
                  if false, sources from the same room as self.character
    - to_caller - sources the caller in this notification (if applicable)
    """

    def __init__(self, caller, receivers: List[str] = None, **to_flags):
        super().__init__(caller, **to_flags)

        self.receiver_list = receivers or []

    def __repr__(self):
        keys = [key for key in self.to_flags if self.to_flags[key]]
        receivers = [name for name in self.receiver_list]
        return f"<ListNotifier: {', '.join(receivers)}; {', '.join(keys)}>"

    def _source_characters(self):
        # Source the receivers on the list.
        for name in self.receiver_list:
            if self.to_flags.get("to_global", False):
                receiver = self.caller.search(name, use_nicks=True, global_search=True)
            else:
                receiver = self.caller.search(name, use_nicks=True)
            if receiver:
                self.receiver_set.add(receiver)

        # Source the caller.
        # The caller is added before the call to Notifier._filter_receivers()
        # so that the caller can be properly filtered as well.  If the caller
        # were added AFTER the filtering, it guarantees the caller is
        # notified but other notifiers could also potentially notify the caller
        # and thus you get a multi-notification that isn't desirable.
        if self.to_flags.get("to_caller", False):
            self.receiver_set.add(self.caller)


class OrgNotifier(Notifier):
    """
    Notifier for sending to members of an organization, based
    on passed in ranks.

    TO_FLAGS Supported:
    - to_staff - include staff in this notification
    - to_caller - source the caller in this notification
    - to_ranks - source characters only from the provided list of ranks
    """

    def __init__(self, caller, org, ranks: List[int] = None, **to_flags):
        super().__init__(caller, **to_flags)

        self.org = org
        self.ranks = ranks or []

    def __repr__(self):
        keys = [key for key in self.to_flags if self.to_flags[key]]
        return f"<OrgNotifier: {self.org}; {', '.join(keys)}>"

    def notify(self, msg: str, options: Optional[OptionsDict] = None):
        # How an organization is notified matters if it's a secret
        # organization.  Thus, overload.
        pass

    def _source_characters(self):
        # Source by rank if any ranks are being used for who will
        # receive this notification.
        if self.to_flags.get("to_ranks", False):
            self.__source_by_ranks()
        else:
            # Otherwise, grab all the online players.
            self.__source_all_members()

        # Source the caller in this notification.
        if self.to_flags.get("to_caller", False):
            self.receiver_set.add(self.caller)

    def __source_by_ranks(self):
        pass

    def __source_all_members(self):
        for member in self.org.online_members():
            self.receiver_set.add(member)


class RoomNotifier(Notifier):
    """
    Notifier for sending to everyone in a room, filtered by
    the to_flags.

    TO_FLAGS Supported:
    - to_player - include non-gm players in this notification
    - to_gm - include player-gms in this notification
    - to_staff - include staff in this notification
    """

    def __init__(
        self,
        caller,
        room,
        **to_flags,
    ):
        super().__init__(caller, **to_flags)
        self.room = room

    def __repr__(self):
        keys = [key for key in self.to_flags if self.to_flags[key]]
        return f"<RoomNotifier: {self.room}; {', '.join(keys)}>"

    def _source_characters(self):
        """
        Generates the source receiver list from all characters
        in the given room.
        """
        if self.room is None:
            raise NotifyError("expected room, received None")

        self.receiver_set = {char for char in self.room.contents if char.is_character}


class ShardhavenNotifier(Notifier):
    pass

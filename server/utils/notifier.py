"""
Notifier.py

Contains classes for various forms of notifying players, PC GMs, staff, and
so on.  The purpose of these classes is to reduce code for sending messages
to specific subsets of the game.  (e.g. - send only to staff in a given room)


USAGE

The base Notifier class supports the following (boolean) to_flags arguments,
each of which default to False if not found in the to_flags argument:

* to_player - this notifier sends to non-gm players
* to_gm - this notifier sends to gm players
* to_staff - this notifier sends to staff players

Subclasses of Notifier differ in how they source characters, which is why
it is required to override _source_characters() when deriving from Notifier.

CODE USAGE
1. Initialize a notifier.  (Example below.)
2. Notifier.generate() -- this must be called after setup but before any
   other methods or properties are called.  Call generate() only once.
3. Notifier.notify() -- this will send your message to the receivers
   generated by Notifier.generate().

INHERITANCE TREE

Notifier
- RoomNotifier
- ListNotifier
    - SelfListNotifier

EXAMPLE CODE

# This code will send "Hello, world!" to all player GMs
# and staff in the given room.
gm_notifier = RoomNotifier(
    caller,
    room=caller.location,
    to_gm=True,
    to_staff=True
)
gm_notifier.generate()
gm_notifier.notify("Hello, world!")
"""

from abc import ABC, abstractmethod
from typing import List, Dict, Optional


class NotifyError(Exception):
    pass


class Notifier(ABC):
    """
    Abstract base class for sending notifications to the game.
    This class is meant to be derived from and its 'protected' code
    utilized in derived classes (to lower code duplication).
    """

    def __init__(
        self,
        caller,
        **to_flags,
    ):
        self.caller = caller
        self.to_flags = to_flags

        self.receiver_set = set()

    def generate(self):
        """Generates the receiver list for this notifier."""
        self._source_characters()
        self._filter_receivers()

    def notify(self, msg: str, options: Optional[Dict[str, bool]] = None):
        """Notifies each receiver of msg with the given options, if any."""
        for rcvr in self.receiver_set:
            rcvr.msg(msg, options)

    def receivers(self):
        for player in self.receiver_set:
            yield player

    def players(self):
        for player in self.receiver_set:
            if not player.check_staff_or_gm():
                yield player

    def gms(self):
        for player in self.receiver_set:
            if player.is_gm():
                yield player

    def staff(self):
        for player in self.receiver_set:
            if player.is_staff():
                yield player

    def receiver_names(self) -> str:
        for player in self.receiver_set:
            yield str(player)

    def player_names(self) -> str:
        for player in self.receiver_set:
            if not player.check_staff_or_gm():
                yield str(player)

    def gm_names(self) -> str:
        for player in self.receiver_set:
            if player.is_gm():
                yield str(player)

    def staff_names(self) -> str:
        for player in self.receiver_set:
            if player.is_staff():
                yield str(player)

    @abstractmethod
    def _source_characters(self):
        pass

    def _filter_receivers(self):
        """Returns all receivers designated by the given receiver flags."""
        player_set = set()
        gm_set = set()
        staff_set = set()

        if self.to_flags.get("to_player", False):
            player_set = set(self.players())

        if self.to_flags.get("to_gm", False):
            gm_set = set(self.gms())

        if self.to_flags.get("to_staff", False):
            staff_set = set(self.staff())

        self.receiver_set = player_set | gm_set | staff_set


class RoomNotifier(Notifier):
    """
    Notifier for sending to everyone in a room, filtered by
    the to_flags.

    TO_FLAGS Supported:
    - to_player - include non-gm players in this notification
    - to_gm - include player-gms in this notification
    - to_staff - include staff in this notification
    """

    def __init__(
        self,
        caller,
        room,
        **to_flags,
    ):
        super().__init__(caller, **to_flags)
        self.room = room

    def _source_characters(self):
        """
        Generates the source receiver list from all characters
        in the given room.
        """
        if not self.room:
            raise NotifyError("expected room, received None")

        self.receiver_set = {char for char in self.room.contents if char.is_character}


class ListNotifier(Notifier):
    """
    Notifier for sending only to the passed in list of receivers,
    then filtered by the to_flags.

    TO_FLAGS Supported:
    - to_player - include non-gm players in this notification
    - to_gm - include player-gms in this notification
    - to_staff - include staff in this notification
    - to_caller - include the caller in this notification (if applicable)
                Callers are filtered out if other to_flags are not set.
    """

    def __init__(self, caller, receivers: List[str] = None, **to_flags):
        super().__init__(caller, **to_flags)

        self.receiver_list = receivers or []

    def _source_characters(self):
        for name in self.receiver_list:
            receiver = self.caller.search(name, use_nicks=True)
            if receiver:
                self.receiver_set.add(receiver)

    def _filter_receivers(self):
        # The caller is added before the call to Notifier._filter_receivers()
        # so that the caller can be properly filtered as well.  If the caller
        # were added AFTER the super() call, it guarantees a place but other
        # notifiers could potentially notify the caller and thus you get a
        # multi-notification that isn't desirable.
        if self.to_flags.get("to_caller", False):
            self.receiver_set.add(self.caller)

        super()._filter_receivers()
